package plugin.consumable;

import core.game.node.entity.player.Player;
import core.game.node.item.Item;
import core.game.world.update.flag.context.Animation;
import core.plugin.Plugin;

/**
 * Represents any item that has a consumption option such as 'Eat' or 'Drink'.
 */
public abstract class Consumable implements Plugin<Object> {

	/**
	 * Represents the item IDs of all the variants of a consumable where the last one is often the empty container, if it has any.
	 */
	protected final int[] ids;

	/**
	 * Represents the effect to apply on the player once the item is consumed.
	 */
	protected final ConsumableEffect effect;

	/**
	 * Represents the messages to send to the player when it consumes the item.
	 */
	protected final String[] messages;

	/**
	 * Represents the animation that the player will execute when consuming the item.
	 */
	protected Animation animation = null;

	public Consumable(final int[] ids, final ConsumableEffect effect, final String... messages) {
		this.ids = ids;
		this.effect = effect;
		this.messages = messages;
	}

	public Consumable(final int[] ids, final ConsumableEffect effect, final Animation animation, final String... messages) {
		this.ids = ids;
		this.effect = effect;
		this.animation = animation;
		this.messages = messages;
	}

	public void consume(final Item item, final Player player) {
<<<<<<< HEAD
		consume(item, player, properties.getHealing());
	}

	/**
	 * Method called when this consumable is consumed.
	 * @note override if needed, generally for extra effects.
	 * @param player the player consuming this consumable.
	 * @param heal the healing amount used to override, (generally to alter amt)
	 * @param messages the messages to show.
	 */
	public void consume(final Item item, final Player player, int heal, String... messages) {

	}

	/**
	 * Method used to handle the interaction between food and a node.
	 * @note override if needed.
	 * @param player the player.
	 * @param node the node.
	 */
	public boolean interact(final Player player, final Node node) {
		return interact(player, node, "");
	}

	/**
	 * Method used to handle the interaction between food and a node.
	 * @note override if needed.
	 * @param player the player.
	 * @param node the node.
	 * @param option the option (if any)
	 */
	public boolean interact(final Player player, final Node node, String option) {
		switch (option) {
		case "empty":
			Item item = (Item) node;
			if (item.getSlot() < 0) {
				return false;
			}
			if (player.getInventory().remove(item, item.getSlot(), true)) {
				player.getPacketDispatch().sendMessage(getEmptyMessage(item));
			}
			if (getEmptyItem() != null) {
				player.getInventory().add(getEmptyItem());
				return true;
			}
			Consumable c = Consumables.getConsumableByItem(item);
			if (c != null) {
				if (c.getEmptyItem() != null) {
					player.getInventory().add(c.getEmptyItem());
				}
			}
			break;
		}
		return true;
	}

	/**
	 * Method used to add a skill bonus to a player.
	 * @param player the player.
	 * @param b the bonus.
	 */
	public void addBonus(final Player player, final SkillBonus b) {
		int level = player.getSkills().getStaticLevel(b.getSkillId());
		level = (int) (b.getBaseBonus() + level + (level * b.getBonus()));
		if (b.getBonus() < 0) {
			player.getSkills().setLevel(b.getSkillId(), level);
			return;
		}
		if (player.getSkills().getLevel(b.getSkillId()) <= level) {
			if (b.getSkillId() == Skills.HITPOINTS) {
				if (player.getSkills().getLifepoints() > player.getSkills().getStaticLevel(Skills.HITPOINTS)) {
					return;
				}
				int difference = level - player.getSkills().getStaticLevel(b.getSkillId());
				player.getSkills().setLevel(b.getSkillId(), player.getSkills().getLifepoints() + difference);
			} else {
				player.getSkills().setLevel(b.getSkillId(), level);
			}
		}
	}

	/**
	 * Method used to remove the item and heal the player.
	 * @param player the player.
	 * @param item the item.
	 */
	public void remove(final Player player, final Item item) {
		if (getProperties() == null) {
			System.err.println("VEXIA SUCKS, PROPERTIES ARE NULL " + item.getId());
			return;
		}
		if (!removed(item, player)) {
			return;
		}
		player.animate(ANIMATION);
		player.getSkills().heal(getProperties().getHealing());
		player.getAudioManager().send(this instanceof Drink ? Drink.SOUND : Food.SOUND);
	}

	/**
	 * Checks if an item is removed.
	 * @param item t he item.
	 * @param player the player.
	 * @return {@code True} if so.
	 */
	public boolean removed(Item item, Player player) {
		if (getProperties().hasNewItem()) {
			if (player.getInventory().replace(getProperties().getNewItem(), item.getSlot()) == null) {
				;
				return false;
			}
=======
		executeConsumptionActions(player);
		final int nextItemId = getNextItemId(item.getId());
		if (nextItemId != -1) {
			player.getInventory().replace(new Item(nextItemId), item.getSlot());
>>>>>>> upstream/development
		} else {
			player.getInventory().remove(item);
		}
		final int initialLifePoints = player.getSkills().getLifepoints();
		Consumables.getConsumableById(item.getId()).effect.activate(player);
		sendMessages(player, initialLifePoints, item, messages);
	}

	protected void sendMessages(final Player player, final int initialLifePoints, final Item item, String[] messages) {
		if (messages.length == 0) {
			sendDefaultMessages(player, item);
			sendHealingMessage(player, initialLifePoints);
		} else {
			sendCustomMessages(player, messages);
		}
	}

	protected void sendHealingMessage(final Player player, final int initialLifePoints) {
		if (player.getSkills().getLifepoints() > initialLifePoints) {
			player.getPacketDispatch().sendMessage("It heals some health.");
		}
	}

	protected void sendCustomMessages(final Player player, final String[] messages) {
		for (String message : messages) {
			player.getPacketDispatch().sendMessage(message);
		}
	}

	protected abstract void sendDefaultMessages(final Player player, final Item item);

	protected abstract void executeConsumptionActions(Player player);

	protected int getNextItemId(final int currentConsumableId) {
		for (int i = 0; i < ids.length; i++) {
			if (ids[i] == currentConsumableId && i != ids.length - 1) {
				return ids[i + 1];
			}
		}
		return -1;
	}

	public String getFormattedName(Item item) {
		return item.getName().replace("(4)", "").replace("(3)", "").replace("(2)", "").replace("(1)", "").trim().toLowerCase();
	}

	@Override
	public Plugin<Object> newInstance(Object arg) throws Throwable {
		Consumables.add(this);
		return this;
	}

	@Override
	public Object fireEvent(String identifier, Object... args) {
		return null;
	}

	public int getHealthEffectValue(Player player) {
		return effect.getHealthEffectValue(player);
	}

	public int[] getIds() {
		return ids;
	}
}
